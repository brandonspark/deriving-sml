(* File generated by CM-Yacc version 2.1 *)

functor ParserFun
   (structure Streamable : STREAMABLE
    structure Arg :
       sig
          type elem
          type span
          type files
          type main

          val main_prog : files -> main
          val cons_files : elem * files -> files
          val nil_files : unit -> files

          datatype terminal =
             ELEM of elem
           | LIBRARY of span
           | GROUP of span
           | IS of span
           | EOF of span

          val error : terminal Streamable.t -> exn
       end)
   :>
   sig
      val parse : Arg.terminal Streamable.t -> Arg.main * Arg.terminal Streamable.t
   end
=

(*

AUTOMATON LISTING
=================

State 0:

start -> . Main  / 0
2 : Main -> . GROUP IS Files  / 0
3 : Main -> . LIBRARY IS Files  / 0

LIBRARY => shift 1
GROUP => shift 2
Main => goto 3

-----

State 1:

3 : Main -> LIBRARY . IS Files  / 0

IS => shift 4

-----

State 2:

2 : Main -> GROUP . IS Files  / 0

IS => shift 5

-----

State 3:

start -> Main .  / 0

$ => accept

-----

State 4:

0 : Files -> . EOF  / 0
1 : Files -> . ELEM Files  / 0
3 : Main -> LIBRARY IS . Files  / 0

ELEM => shift 8
EOF => shift 7
Files => goto 6

-----

State 5:

0 : Files -> . EOF  / 0
1 : Files -> . ELEM Files  / 0
2 : Main -> GROUP IS . Files  / 0

ELEM => shift 8
EOF => shift 7
Files => goto 9

-----

State 6:

3 : Main -> LIBRARY IS Files .  / 0

$ => reduce 3

-----

State 7:

0 : Files -> EOF .  / 0

$ => reduce 0

-----

State 8:

0 : Files -> . EOF  / 0
1 : Files -> . ELEM Files  / 0
1 : Files -> ELEM . Files  / 0

ELEM => shift 8
EOF => shift 7
Files => goto 10

-----

State 9:

2 : Main -> GROUP IS Files .  / 0

$ => reduce 2

-----

State 10:

1 : Files -> ELEM Files .  / 0

$ => reduce 1

-----

lookahead 0 = $ 

*)

struct
local
structure Value = struct
datatype nonterminal =
nonterminal
| elem of Arg.elem
| span of Arg.span
| files of Arg.files
| main of Arg.main
end
structure ParseEngine = ParseEngineFun (structure Streamable = Streamable
type terminal = Arg.terminal
type value = Value.nonterminal
val dummy = Value.nonterminal
fun read terminal =
(case terminal of
Arg.ELEM x => (1, Value.elem x)
| Arg.LIBRARY x => (2, Value.span x)
| Arg.GROUP x => (3, Value.span x)
| Arg.IS x => (4, Value.span x)
| Arg.EOF x => (5, Value.span x)
)
)
in
val parse = ParseEngine.parse (
ParseEngine.next5x1 "\128\128\130\131\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\133\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\134\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\127\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\137\128\128\128\136\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\137\128\128\128\136\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128{\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128~\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\137\128\128\128\136\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128|\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128}\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128",
ParseEngine.next5x1 "\128\131\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\134\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\137\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\138\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128\128",
Vector.fromList [(0,1,(fn _::rest => Value.files(Arg.nil_files {})::rest|_=>raise (Fail "bad parser"))),
(0,2,(fn Value.files(arg0)::Value.elem(arg1)::rest => Value.files(Arg.cons_files {2=arg0,1=arg1})::rest|_=>raise (Fail "bad parser"))),
(1,3,(fn Value.files(arg0)::_::_::rest => Value.main(Arg.main_prog arg0)::rest|_=>raise (Fail "bad parser"))),
(1,3,(fn Value.files(arg0)::_::_::rest => Value.main(Arg.main_prog arg0)::rest|_=>raise (Fail "bad parser")))],
(fn Value.main x => x | _ => raise (Fail "bad parser")), Arg.error)
end
end
